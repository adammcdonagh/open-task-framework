import argparse
import os
import sys
import datetime
import json
from opentaskpy.config.schemas import validate_json
from glob import glob
from opentaskpy.taskhandlers.transfer import Transfer
import logging
from enum import Enum
import re
import jinja2
from jinja2 import Environment, Template, Undefined
from jinja2.exceptions import UndefinedError


def recurse_json(d):
    for k, v in d.items():
        if isinstance(v, dict):
            recurse_json(v)
        else:
            # Evaluate any variables
            if isinstance(v, str):
                pattern = r"\$\{([^\}]+)\}"
                m = re.search(pattern, v)
                if m:
                    variable_name = m.group(1)
                    variable = global_variables[variable_name]
                    logging.log(12, f"Found variable: {variable_name} - Value is: {variable}")
                    v = re.sub(pattern, variable, v)
                    logging.log(12, v)


def delta_days(value, days):
    return value + datetime.timedelta(days)


def main():
    CONFIG_PATH = f"{os.path.dirname(os.path.realpath(__file__))}/../cfg"
    GLOBAL_VERBOSITY = 1

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-t", "--taskId", help="Name of the JSON config to run", type=str, required=True)
    parser.add_argument("-v", "--verbosity", help="Increase verbosity", type=int)
    parser.add_argument("-c", "--configDir",
                        help="Directory containing task configurations", type=str)

    args = parser.parse_args()

    if args.configDir:
        CONFIG_PATH = args.configDir

    logging.basicConfig(
        format="%(asctime)s — %(name)s — %(levelname)s — %(message)s", level=logging.INFO)
    logging.addLevelName(11, "VERBOSE2")
    logging.addLevelName(12, "VERBOSE1")

    logger = logging.getLogger()
    logger.log(11, f"Log verbosity: {args.verbosity}")

    if args.verbosity == 3:
        logger.setLevel(logging.DEBUG)
    elif args.verbosity == 2:
        logger.setLevel(11)
    elif args.verbosity == 1:
        logger.setLevel(12)

    # Force Jinja2 to log undefined variables
    LoggingUndefined = jinja2.make_logging_undefined(logger=logger, base=jinja2.Undefined)
    template_env = jinja2.Environment(undefined=jinja2.StrictUndefined)
    template_env.filters["delta_days"] = delta_days

    logger.log(12, "Looking in {CONFIG_PATH}")

    active_task_definition = ()

    # Load global config variables
    global_variables = dict()
    variable_configs = []
    file_types = (".json.j2", ".json")
    for file_type in file_types:
        variable_configs.extend(glob(f"{CONFIG_PATH}/**/variables{file_type}", recursive=True))
    if not variable_configs:
        logging.error("Couldn't find any variables.(json|json.j2) files")
        sys.exit(1)
    else:
        for variable_file in variable_configs:
            with open(variable_file) as json_file:
                this_variable_config = json.load(json_file)
                global_variables = global_variables | this_variable_config

    # Load configuration
    json_config = glob(f"{CONFIG_PATH}/**/{args.taskId}.json", recursive=True)
    if not json_config or len(json_config) != 1:
        logging.error(f"Couldn't find task with name: {args.taskId}")
        sys.exit(1)
    else:
        found_file = json_config[0]
        logger.log(12, f"Found: {found_file}")

        # Load the JSON file
        with open(found_file) as json_file:

            json_content = json_file.read()
            template = Template(json_content)
            # Render the template without evaluating any variables yet
            rendered_template = template.render()

            # From this, convert it to JSON and pull out the variables key if there is one
            task_definition = json.loads(rendered_template)
            # Extend or replace any local variables for this task
            if "variables" in task_definition:
                global_variables = global_variables | task_definition["variables"]

            # We need to evaluate the variables themselves, incase theres any recursion
            # Convert the variables to a JSON string which we can process with the jinja2 templater
            MAX_DEPTH = 5
            current_depth = 0
            previous_render = None

            variables_template = template_env.from_string(json.dumps(global_variables))
            variables_template.globals['now'] = datetime.datetime.utcnow
            evaluated_variables = variables_template.render(global_variables)

            while evaluated_variables != previous_render and current_depth < MAX_DEPTH:
                previous_render = evaluated_variables

                variables_template = template_env.from_string(evaluated_variables)
                evaluated_variables = variables_template.render(json.loads(evaluated_variables))

                current_depth += 1
                if current_depth >= MAX_DEPTH:
                    logging.error("Reached max depth of recursive template evaluation. Please check the task as variable definitions for infinite recursion")
                    sys.exit(1)

                global_variables = json.loads(evaluated_variables)

            template = template_env.from_string(json_content)
            rendered_template = template.render(global_variables)
            active_task_definition = json.loads(rendered_template)
            logging.log(12, f"Evalated task definition: {json.dumps(active_task_definition)}")

    # Loop though every attribute and check for variables to evaluate
    # for key in active_task_definition.keys():

    # recurse_json(active_task_definition)

    # Now we've loaded the config, determine what to do with it
    if "type" not in active_task_definition:
        logger.error("Invalid task configuration. Cannot continue")
        sys.exit(1)
    elif active_task_definition["type"] == "transfer":
        # Hand off to the transfer module
        logger.log(12, "Transfer")
        # Validate the schema
        if not validate_json(active_task_definition):
            logger.error("JSON format does not match schema")
            sys.exit(1)

        transfer = Transfer(args.taskId, active_task_definition)
        rc = transfer.run()

        sys.exit(rc)

    elif active_task_definition["type"] == "execution":
        # Hand off to the execuiton module
        logger.log(12, "Execution")
    elif active_task_definition["type"] == "batch":
        # Hand off to the batch module
        logger.log(12, "Batch")
    else:
        logger.error(f"Unknown task type!")
        sys.exit(1)


if __name__ == "__main__":
    main()
