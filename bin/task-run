import argparse
import os
import sys
import datetime
import json
from opentaskpy.config.schemas import validate_json
from glob import glob
from opentaskpy.taskhandlers.transfer import Transfer
import logging
import jinja2
from jinja2 import Template

CONFIG_PATH = f"{os.path.dirname(os.path.realpath(__file__))}/../cfg"
GLOBAL_VERBOSITY = 1
MAX_DEPTH = 5

# Not needed now we're using Jinja2
# def recurse_json(d):
#     for _, v in d.items():
#         if isinstance(v, dict):
#             recurse_json(v)
#         else:
#             # Evaluate any variables
#             if isinstance(v, str):
#                 pattern = r"\$\{([^\}]+)\}"
#                 m = re.search(pattern, v)
#                 if m:
#                     variable_name = m.group(1)
#                     variable = global_variables[variable_name]
#                     logging.log(12, f"Found variable: {variable_name} - Value is: {variable}")
#                     v = re.sub(pattern, variable, v)
#                     logging.log(12, v)


def delta_days(value, days):
    return value + datetime.timedelta(days)


def template_lookup(plugin):
    logging.log(11, "got call to lookup function")


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--taskId", help="Name of the JSON config to run", type=str, required=True)
    parser.add_argument("-v", "--verbosity", help="Increase verbosity", type=int)
    parser.add_argument("-c", "--configDir", help="Directory containing task configurations", type=str)

    args = parser.parse_args()

    if args.configDir:
        global CONFIG_PATH
        CONFIG_PATH = args.configDir

    logging.basicConfig(format="%(asctime)s — %(name)s — %(levelname)s — %(message)s", level=logging.INFO)
    logging.addLevelName(11, "VERBOSE2")
    logging.addLevelName(12, "VERBOSE1")

    logger = logging.getLogger()
    logger.log(11, f"Log verbosity: {args.verbosity}")

    if args.verbosity == 3:
        logger.setLevel(logging.DEBUG)
    elif args.verbosity == 2:
        logger.setLevel(11)
    elif args.verbosity == 1:
        logger.setLevel(12)

    # Force Jinja2 to log undefined variables
    LoggingUndefined = jinja2.make_logging_undefined(logger=logger, base=jinja2.Undefined)  # noqa
    template_env = jinja2.Environment(undefined=jinja2.StrictUndefined)
    template_env.filters["delta_days"] = delta_days

    logger.log(12, f"Looking in {CONFIG_PATH}")

    active_task_definition = ()

    # Load global config variables
    global_variables = dict()
    variable_configs = []
    file_types = (".json.j2", ".json")
    for file_type in file_types:
        variable_configs.extend(glob(f"{CONFIG_PATH}/**/variables{file_type}", recursive=True))
    if not variable_configs:
        logging.error("Couldn't find any variables.(json|json.j2) files")
        sys.exit(1)
    else:
        for variable_file in variable_configs:
            with open(variable_file) as json_file:
                this_variable_config = json.load(json_file)
                global_variables = global_variables | this_variable_config

    # Load configuration
    json_config = glob(f"{CONFIG_PATH}/**/{args.taskId}.json", recursive=True)
    if not json_config or len(json_config) != 1:
        logging.error(f"Couldn't find task with name: {args.taskId}")
        sys.exit(1)
    else:
        found_file = json_config[0]
        logger.log(12, f"Found: {found_file}")

        # Load the JSON file
        with open(found_file) as json_file:

            json_content = json_file.read()
            template = Template(json_content)
            # Render the template without evaluating any variables yet
            rendered_template = template.render()

            # From this, convert it to JSON and pull out the variables key if there is one
            task_definition = json.loads(rendered_template)
            # Extend or replace any local variables for this task
            if "variables" in task_definition:
                global_variables = global_variables | task_definition["variables"]

            # We need to evaluate the variables themselves, incase theres any recursion
            # Convert the variables to a JSON string which we can process with the jinja2 templater
            global MAX_DEPTH
            current_depth = 0
            previous_render = None

            variables_template = template_env.from_string(json.dumps(global_variables))
            variables_template.globals["now"] = datetime.datetime.utcnow

            # Define lookup function
            variables_template.globals["lookup"] = template_lookup

            evaluated_variables = variables_template.render(global_variables)

            while evaluated_variables != previous_render and current_depth < MAX_DEPTH:
                previous_render = evaluated_variables

                variables_template = template_env.from_string(evaluated_variables)
                evaluated_variables = variables_template.render(json.loads(evaluated_variables))

                current_depth += 1
                if current_depth >= MAX_DEPTH:
                    logging.error(
                        "Reached max depth of recursive template evaluation. Please check the task as variable definitions for infinite recursion"
                    )
                    sys.exit(1)

                global_variables = json.loads(evaluated_variables)

            template = template_env.from_string(json_content)
            rendered_template = template.render(global_variables)
            active_task_definition = json.loads(rendered_template)
            logging.log(12, f"Evalated task definition: {json.dumps(active_task_definition)}")

    # Loop though every attribute and check for variables to evaluate
    # for key in active_task_definition.keys():

    # recurse_json(active_task_definition)

    # Now we've loaded the config, determine what to do with it
    if "type" not in active_task_definition:
        logger.error("Invalid task configuration. Cannot continue")
        sys.exit(1)
    elif active_task_definition["type"] == "transfer":
        # Hand off to the transfer module
        logger.log(12, "Transfer")
        # Validate the schema
        if not validate_json(active_task_definition):
            logger.error("JSON format does not match schema")
            sys.exit(1)

        transfer = Transfer(args.taskId, active_task_definition)
        rc = transfer.run()

        sys.exit(rc)

    elif active_task_definition["type"] == "execution":
        # Hand off to the execuiton module
        logger.log(12, "Execution")
    elif active_task_definition["type"] == "batch":
        # Hand off to the batch module
        logger.log(12, "Batch")
    else:
        logger.error("Unknown task type!")
        sys.exit(1)


if __name__ == "__main__":
    main()
